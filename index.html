<html>

 <head>
     <title>Game</title>
     <script type="text/javascript" src="js/dollar.js"></script>
     <script type="text/javascript" src="js/phaser.min.js"></script>
     <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
     <script src="js/shape.js"></script>
 </head>

 <body>
    <script>
        var w = window.innerWidth * window.devicePixelRatio,
        h = window.innerHeight * window.devicePixelRatio;
        var game = new Phaser.Game(w, h, Phaser.AUTO, '', { preload: preload, create: create, update: update, render: render });

    var canvas;

    var RIGHT = 1, LEFT = 0;

    var player;
    var platforms;
    var cursors;
    var stars, star;
    var background;
    var boxs, box;
    var enemies, enemy; 
    var ground;

    var score = 0;
    var scoreText;
    var milliseconds = 0;
    var seconds = 0;
    var minutes = 0;
    
    var starH=22;
    var starW=24;

    var playerH = 200;
    var playerW = 300;

    var enemyH = 89;
    var enemyW = 89;

    var boomH = 94;
    var boomW = 95;

    var solidH = 100;
    var solidW = 100;

    var boxH=51;
    var boxW = 50;

    var bitmapW=400;
    var bitmapH=300;

    var platformW=400;
    var platformH=32;

    var playerV=150;

    var lecters;
    var lecter;
    var shape=0;
    var map;

    var audio_game;
    var effect_sound;


    var explosions;
    var boom;

    var lives;
    var live;


    var turn = 0;                                                               //controlla se è il turno di scirvere o meno.
    var bomb_state = 0;                                                         //tiene conto dello stato della bomba
    
    var shelves;
    var shelf;



    this.reservedArea = { area: [] };
     


    function preload() {

        /*Imposta limiti di risoluzione 2048x1536 retina display */
        game.scale.maxWidth = 1920;
        game.scale.maxHeight = 1080;

        /*Vogliamo scalare fino a quando possibile, ma proporzionalmente*/
        game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
        game.scale.setScreenSize();


        game.load.image('forest', 'assets/bk_smaller2.jpg');
        game.load.image('ground', 'assets/solid.jpg');
        game.load.image('star', 'assets/star.png');
        game.load.spritesheet('enemy', 'assets/bombe_.png', enemyW, enemyH);
        game.load.spritesheet('dude', 'assets/player.png', playerW, playerH);
        game.load.image('fumetto', 'assets/fumetto.jpg');
        game.load.audio('audio_game', 'assets/audio_game.mp3');
        game.load.audio('effect_sound', 'assets/effect_sound.mp3');
        game.load.image('life', 'assets/life.png');
        game.load.image('platform', 'assets/platform.png');
        game.load.spritesheet('boom', 'assets/boom.png', boomW, boomH);

    }


    function create() {

        reservedArea.area.push({ "x": 0, "y": 0, "x_": 0, "y_": 0,"posX":0}); //Lo inizializzo in modo che abbia almento un elemento.

        game.physics.startSystem(Phaser.Physics.ARCADE);                                   //abilito la fisica
        game.world.setBounds(0, 0, 9999999999, 600);                                             //imposto l'area di copertura della camera

        audio_game = game.add.audio('audio_game');
        effect_sound = game.add.audio('effect_sound');
        audio_game.addMarker('audio_game', 0, 7.8, 0.2, true);
        effect_sound.addMarker('boom', 0, 2, 0.7, false);
        effect_sound.addMarker('game_over', 2.2, 3.75, 1, false);
        audio_game.play('audio_game');
  
        background = game.add.tileSprite(0, 0,w,h,'forest');             
        platforms = game.add.group();                                                      //il platform contiene la terra e le due sporgenze su cui possiamo saltare
        platforms.enableBody = true;                                                       //Noi abiliteremo la fisica per tutti gli oggetti che sono stati creati in questo gruppo


        ground = platforms.create(0, game.world.height - solidH, 'ground');                    //adesso creiamo il ground
        ground.body.immovable = true;                                                      // questo impedisce la caduta del ground
        ground.body.collideWorldBounds=true;

        enemies = game.add.group();
        enemies.enableBody = true;

        stars = game.add.group();                                                          //creaiamo il gruppo stars
        stars.enableBody = true;                                                           //abilitiamo tutte le stelle che sono state create in questo gruppo

        shelves = game.add.group();
        shelves.enableBody = true;

        lecters = game.add.group();
        lecters.enableBody = true;

        lives = game.add.group();
        lives.fixedToCamera = true;

        explosions = game.add.group();
        explosions.enableBody = true;




        life = lives.create(w - 176, 16, 'life');
        life = lives.create(w - 123, 16, 'life');
        life = lives.create(w - 70, 16, 'life');

        player = game.add.sprite(0, game.world.height - solidH-playerH, 'dude');
        game.physics.arcade.enable(player);                                                //abilità la fisica al player

        player.body.bounce.y = 0.2;                                                   /*impostiamo fisica rimbalzo*/
        player.body.gravity.y = 600;                                                        /*impostiamo la gravita*/
        player.body.collideWorldBounds = true;                                             /*impostiamo collisioni*/

        player.animations.add('left', [3,4,5], 10, true);                             //animazione cammina a sinistra
        player.animations.add('right', [0,1,2], 10, true);                            //animazione cammina a destr                                                                    
        cursors = game.input.keyboard.createCursorKeys();                                  //creiamo i controlli

        enemies.callAll('animations.add', 'animations', 'left', [1], 10, true);   //invoco la funzione animations.add come se la stessero chiamando i figli del gruppo   
        enemies.callAll('animations.add', 'animations', 'right', [0], 10, true);


    
        scoreText = game.add.text(16, 16, 'Score: 0', { fontSize: '32px', fill: '#000' });      //stampo lo score attuale
        scoreText.fixedToCamera = true;

        background.fixedToCamera = true;                                                        //il background è un elemento fisso per la camera
        ground.fixedToCamera = true;                                                            //il ground è un elemento fisso per la camera
        ground.scale.setTo(w /solidW,1);


        game.camera.follow(player);                                                             //la camera deve inseguire il giocatore
        game.camera.deadzone = new Phaser.Rectangle(w / 2 + playerW / 2, 0, 0, 0);
        
        canvas = document.getElementsByTagName('body')[0];                                      //prelevo la canvas del gioco
        classicalResize();

        player.body.velocity.x = playerV; //Muovi a destra
        player.animations.play('right');
    }

    function update() {
        
        game.physics.arcade.collide(player,platforms); //collisione tra il personaggio e il platform.
        game.physics.arcade.collide(player,shelves); //collisione tra il personaggio e il platform.
        game.physics.arcade.collide(stars, platforms);
        game.physics.arcade.overlap(player, stars, collectStar, null, this); /* se c'è un overlap tra  players e stars viene invocato il metodo collectStar*/
        game.physics.arcade.collide(enemies, platforms);

        if(enemies.countLiving()>0){
            game.physics.arcade.overlap(enemies.getFirstAlive(), player, match, null, this);
        }

        if(shelves.countLiving()>0){
         game.physics.arcade.overlap(shelves.getFirstAlive(), player, match_shelves, null, this);
        }

        createRandomElementInMap(game.camera.x+w,game.world.height-enemyH-solidH,enemies,18,1500,'enemy',1,0,0,0,true,true);
        if(enemies.countLiving()>0){
         enemies.getFirstAlive().frame = 1;
         enemies.getFirstAlive().body.velocity.x = -80;
        }

        createRandomElementInMap(game.camera.x+w,0,stars,50,30,'star',50,starW*2,0,900,true,true);   
        createRandomElementInMap(game.camera.x+w,game.world.height-playerW-solidH/2,shelves,50,30,'platform',Math.random()*100%3,platformW+platformW/4,platformH,0,true,true);


        if (game.input.activePointer.isDown) {
           
                var x = game.input.activePointer.position.x;
                var y = game.input.activePointer.position.y;
             

                if ((x >= (reservedArea.area[0].x - game.camera.x) && x <= (reservedArea.area[0].x_ - game.camera.x)) && (y >= reservedArea.area[0].y && y <= reservedArea.area[0].y_)) {
                    turn = shape.captureInputData();
                    enemies.getFirstAlive().body.velocity.x = 0;
                    lecters.getFirstAlive().body.velocity.x = 0;
                } else if(player.body.touching.down) {
                        player.body.velocity.y = -650;
                        player.body.velocity.x = playerV;

              
                }
              
        } 

        if (enemies.countLiving() > 0) {
            if (enemies.getFirstAlive().position.x - player.position.x < playerW + 20) {
                player.frame = 0;
                player.body.velocity.x = 0;
                player.animations.stop();

                var xLecter = enemies.getFirstAlive().position.x + enemyW / 2;
                var yLecter = game.world.height - bitmapH - solidH - enemyH;
                if (!shape) {
                    createLecter(xLecter, yLecter, "left square bracket");
                }
                enemies.getFirstAlive().body.velocity.x = 0;
            }
        }

        if (game.input.activePointer.isUp) {
            if (turn == 1) {
                var res = shape.checkInputData();

                enemy = enemies.getFirstAlive();
                lecter = lecters.getFirstAlive();
                if (res.point == 0 && res.npoint == 0) {
                    console.log("Error!");
                    shape = 0;
                } else {
                    var complex_point = (res.point / (res.npoint) * 100);
                    var figure = res.type;
                    shape.bmd.clear();
                    if (complex_point >= 70 && figure == shape.type) {
                        enemy.kill();
                        lecter.kill();
                        score += 20;//aumento di 20 punti
                        scoreText.text = 'Score: ' + score; //inserisco un nuovo valore nella scritta
                    } else {
                        if (lives.countLiving() > 1) {
                            lives.getFirstAlive().kill();
                            effect_sound.play('boom');
                            var x = enemy.position.x;
                            var y = enemy.position.y;
                            createBoom(x, y);
                        } else {
                            lives.getFirstAlive().kill();
                            player.kill();
                            audio_game.stop('audio_game');
                            effect_sound.play('boom');
                            effect_sound.play('game_over');
                            var x = enemy.position.x;
                            var y = enemy.position.y;
                            createBoom(x, y);
                        }
                    }
                    shape = 0;             
                    player.body.velocity.x = playerV; //Muovi a destra
                    player.animations.play('right');
                    reservedArea.area[0].x = 0;
                    reservedArea.area[0].posX = 0;
                    reservedArea.area[0].x_ = 0;
                    lecter.kill();
                    enemy.kill();

                    //console.log(" PunteggioTot:(" + (res.point / (res.npoint) * 100) + ")." + " Figura:" + res.type);
                }
      
                turn = 0;
            }
        }

   

        background.tilePosition.x = -game.camera.x; //aggiorno la posizione del background
        clearAll();
    }
  
        function createRandomElementInMap(x,y,group,prob,scale,type,number,offsetX,offsetY,gravity,immovable,collide){
            var position = game.camera.x % scale;
            if ((position>= 0&&position<=10&&group.countLiving()==0) && game.camera.x != 0) {
                 if (Phaser.Math.chanceRoll(prob)) 
                    for(var i=0;i<number;i++){
                      element = group.create(x+(i*offsetX),y-(i*offsetY),type);
                      element.body.gravity.y = gravity; 
                      element.body.immovable = immovable; 
                      element.body.collideWorldBounds = collide;
                    }
                }
            }
        
        
  

        function onSwipeUp() {
            return ((game.input.activePointer.positionDown.y - game.input.activePointer.position.y) > 50 && game.input.activePointer.duration > 100 && game.input.activePointer.duration < 250);
        }

        function onSwipeRight() {
            return ((game.input.activePointer.position.x - game.input.activePointer.positionDown.x) > 50 && game.input.activePointer.duration > 100 && game.input.activePointer.duration < 250);
        }

        function onSwipeLeft() {
            return ((game.input.activePointer.positionDown.x - game.input.activePointer.position.x) > 50 && game.input.activePointer.duration > 100 && game.input.activePointer.duration < 250);
        }

        function render() {
            game.debug.cameraInfo(game.camera, 32, 32);
            game.debug.spriteCoords(player, 32, 200);
        }

    function classicalResize() {
        
    }
 
    function collectStar(player, star) {
        star.kill();                                //rimuove la stella in cui c'è stato l'overlap.
        score += 10;                                //aumento lo score di 10 punti
        scoreText.text = 'Score: ' + score;         //inserisco un nuovo valore nella scritta
    }



    function match(enemy, player) {

 
    }

     function match_shelves(shelf, player) {
        player.body.velocity.x = playerV;
    }

    function clearAll() {
        if(stars.countLiving()>0){
            var posStarX = stars.getFirstAlive().x;
            if (game.camera.x > posStarX+starW) {
                stars.getFirstAlive().kill();
            }
        }

        if(shelves.countLiving()>0){
            var posPlatformX = shelves.getFirstAlive().x;
            if (game.camera.x > posPlatformX+platformW) {
                shelves.getFirstAlive().kill();
            }
        }

       if(enemies.countLiving()>0){
            var posEnemyX = enemies.getFirstAlive().x;
            if (game.camera.x > posEnemyX+enemyW) {
                enemies.getFirstAlive().kill();
            }
        }

        if(explosions.countLiving()>0){
            var posBoomX = explosions.getFirstAlive().x;
            if (game.camera.x > posBoomX) {
                explosions.getFirstAlive().kill();
            }
        }

    }


    function createBoom(x, y) {
        boom = explosions.create(x, y, 'boom');
        boom.body.collideWorldBounds = true;
        boom.animations.add('stop', [0, 1, 2, 3, 4, 5], 10, false);
        boom.animations.play('stop');
    }

    function createLecter(x, y, type) {
        var xLecter = x + enemyW / 2;
        var yLecter = y;
        shape = new Shape(xLecter-game.camera.x, yLecter, bitmapW, bitmapH, type);
        shape.initializeBitmapData(game.cache.getImage('fumetto'));
        lecter = lecters.create(xLecter, yLecter, shape.bmd);
        reservedArea.area.splice(0,1);
        reservedArea.area.push({ "x": xLecter, "y": yLecter, "x_": xLecter + bitmapW, "y_": yLecter + bitmapH, "posX": xLecter });
    }

    </script>
  </body>

 </html>
